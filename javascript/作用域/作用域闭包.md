## 作用域闭包
-  在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包
- 循环和闭包
```
for(var i=1;i<=5;i++){
  //给匿名函数定义一个具名
  setTimeout(function timer(){
    console.log(i); //5次6
  },i*1000)
}

//·这个循环的终止条件是i不再<=5，条件首次成立时i的值是6
//·延迟函数的回调会在循环结束时才执行
//·尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i

for(var i=1;i<=5;i++){
  (function(){
    var j=i;
    setTimeout(function timer(){
      console.log(j);
    },i*1000)
  })()
}
//在for循环中使用IIFE（立即执行函数）创建中更多的词法作用域
//每次迭代它都拥有自己的变量j，用来储存i的值

for(var i=1;i<=5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j);
    },j*1000)
  })(i)
}
//IIFE也不过是函数，因此可以将i传递进去
//在迭代中使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量可供访问

for(let i=1;i<=5;i++){
  setTimeout(function timer(){
    console.log(i);
  },i*1000);
}
//将每次for循环都转换成一个可以关闭的作用域
//let声明的特殊行为指出变量在循环的过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量
```