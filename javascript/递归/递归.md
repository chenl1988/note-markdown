## 递归

- 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要多次重复计算，大大减少了程序的代码量。

- 步骤：
  - 寻找出口，递归一定要有一个出口，锁定出口，保证不会死循环
  - 递归条件，符合递归条件，自己调用自己

- 方法：
  - 首先先去找临界值，既无需计算，获得的值
  - 找这一次和上一次的关系
  - 假设当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出这次的运行结果。

- 特点：
  - 必须有参数
  - 必须有return
```
/**
 * 深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值 
 * @param {*} origin 是被克隆的对象
 */
function deepClone(origin){
  let target = Array.isArray(origin)?[]:{};
  //遍历原对象
  if(typeof origin === "object" && origin){
    for(var key in origin){
      if(typeof origin[key] === "object" && origin[key]){
        target[key] = deepClone(origin[key]);
      }else{
        target[key] = origin[key];
      }
    }
  }
  return target;
}
let obj = [5,6,{a:8,b:10}];
console.log(deepClone(obj));


/**
 * Array的方法flat很多浏览器还未能实现，请写一个flat方法，实现扁平化嵌套数组
 * 实现思路和Deep Clone非常相似
 */
Array.prototype.flat = function(){
  var arr = [];
  this.forEach((item,index)=>{
    if(Array.isArray(item)){
      arr = arr.concat(item.flat());
    }else{
      arr.push(item);
    }
  })
  return arr;
}
let arr = [[2],3,[4,[5]]];
console.log(arr.flat());
```